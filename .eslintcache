[{"/Users/a58/Desktop/my/beautiful/src/index.tsx":"1","/Users/a58/Desktop/my/beautiful/src/reportWebVitals.ts":"2","/Users/a58/Desktop/my/beautiful/src/App.tsx":"3","/Users/a58/Desktop/my/beautiful/src/components/reverse/index.tsx":"4","/Users/a58/Desktop/my/beautiful/src/components/cube/index.tsx":"5","/Users/a58/Desktop/my/beautiful/src/components/demo/index.tsx":"6","/Users/a58/Desktop/my/beautiful/src/components/Reverse/index.tsx":"7","/Users/a58/Desktop/my/beautiful/src/components/Cube/index.tsx":"8","/Users/a58/Desktop/my/beautiful/src/components/Fireworks/index.tsx":"9","/Users/a58/Desktop/my/beautiful/src/components/Fireworks/js/index.js":"10"},{"size":500,"mtime":1612167040698,"results":"11","hashOfConfig":"12"},{"size":425,"mtime":1612167040698,"results":"13","hashOfConfig":"12"},{"size":2462,"mtime":1613986686275,"results":"14","hashOfConfig":"12"},{"size":965,"mtime":1612233767869,"results":"15","hashOfConfig":"12"},{"size":7704,"mtime":1613984456444,"results":"16","hashOfConfig":"12"},{"size":798,"mtime":1613959768240,"results":"17","hashOfConfig":"12"},{"size":965,"mtime":1612233767869,"results":"18","hashOfConfig":"12"},{"size":7704,"mtime":1613984456444,"results":"19","hashOfConfig":"12"},{"size":1718,"mtime":1613987717926,"results":"20","hashOfConfig":"12"},{"size":13980,"mtime":1613986223788,"results":"21","hashOfConfig":"12"},{"filePath":"22","messages":"23","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},"19d2edm",{"filePath":"25","messages":"26","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},{"filePath":"27","messages":"28","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"29","messages":"30","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"31"},{"filePath":"32","messages":"33","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"34","messages":"35","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"36","usedDeprecatedRules":"24"},{"filePath":"37","messages":"38","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},{"filePath":"39","messages":"40","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"41","usedDeprecatedRules":"24"},{"filePath":"42","messages":"43","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"44","messages":"45","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"46","usedDeprecatedRules":"47"},"/Users/a58/Desktop/my/beautiful/src/index.tsx",[],["48","49"],"/Users/a58/Desktop/my/beautiful/src/reportWebVitals.ts",[],"/Users/a58/Desktop/my/beautiful/src/App.tsx",[],"/Users/a58/Desktop/my/beautiful/src/components/reverse/index.tsx",[],["50","51"],"/Users/a58/Desktop/my/beautiful/src/components/cube/index.tsx",["52","53"],"/Users/a58/Desktop/my/beautiful/src/components/demo/index.tsx",["54"],"import React, { useRef, useEffect, useState } from 'react';\n\ninterface DemoProps {\n  text?: string;\n}\n\ninterface anyProps {\n  [x: string]: string | number | number[];\n}\n\nconst usePrevious = (state: any) => {\n  const ref = useRef();\n  useEffect(() => {\n    ref.current = state;\n  });\n  return ref.current;\n};\n\nconst Demo: React.FC<DemoProps> = (props) => {\n  const { text } = props;\n  const [now, setNow] = useState(0);\n  const last = usePrevious(now);\n  const add = () => {\n    setNow(now + 1);\n  };\n  const lock = () => {\n    console.log(now);\n  };\n  return (\n    <div>\n      <p>{text}</p>\n      <button onClick={add}>添加值</button>\n      <button onClick={lock}>打印值</button>\n      <p>\n        上一个值：{last}，现在的值{now}\n      </p>\n    </div>\n  );\n};\n\nexport default Demo;\n","/Users/a58/Desktop/my/beautiful/src/components/Reverse/index.tsx",[],"/Users/a58/Desktop/my/beautiful/src/components/Cube/index.tsx",["55","56"],"import React, { useRef, useMemo } from 'react';\nimport Style from './index.module.scss';\n/**\n * 设：这个立方体（长方体）在你的正前方，它一共有6个面\n * 正面的平面（对着你的面）的 index 为 0，\n * 右侧面的平面 index 为 1，\n * 后面的平面（也即是和正面平面相对的那个面） index 为 2\n * 左侧面的平面（也即是和右侧面相对的那个面） index 为 3\n * 下面的平面 index 为 4\n * 上面的平面（也就是下面相对的那个面） index 为 5\n */\n\n/**\n * 根据立方体的特性可得\n * 0（前面）和 2（后面） 的宽高必须一致\n * 1（右面）和 3（左面） 的宽高必须一致\n * 4（下面）和 5（上面） 的宽高必须一致\n * 实际上，只要确定三条边就能确定一个立方体，那就是 正面的宽(x) 正面的高(y) 右侧面的宽(z)\n * 所以 planeSize 的参数，只需要传入3个值[x, y, z]就能确定立方体\n */\ninterface CubeProps {\n  planeSize: number[]; // 传入x, y, z 的值\n  planeNode: React.ReactElement[]; // 这个数组的项必须是jsx，每个jsx的索引对应着每个面，映射关系参照上面的注释\n  index: number; // 要显示在正前方的面的索引值， 参照上面的注释\n  speed?: number; // 切换平面时的运动速度\n  unit?: 'px' | 'rem' | 'vw' | 'vh'; // 传入的x, y, z 的值的长度单位\n  // 1. 在 fixed参数值 为 false 的情况下，\n  // row 与 row-reverse 的效果等价， 都是左右切换，也就是在Y轴上切换\n  // column 与 column-reverse 的效果等价， 都是上下切换，也就是在X轴上切换\n  // 因为在 fixed参数值 为 false 的情况下平面切换时，会自动寻找最短路径\n\n  // 2. 在 fixed参数值 为 true 的情况下\n  // row：不会寻找最短路径， 总是从左向右旋转\n  // row-reverse：不会寻找最短路径， 总是从右向左旋转\n  // column：不会寻找最短路径，总是从上向下旋转\n  // column-reverse：不会寻找最短路径， 总是从下向上旋转\n  direction?: 'row' | 'row-reverse' | 'column' | 'column-reverse';\n  fixed?: boolean;\n}\n\ninterface dataStorageProps {\n  lastIndex: number | null;\n  lastDeg: number[];\n}\n\n// x 轴 顺时针为正数，逆时针为负数\n// y 轴 顺时针为负数，逆时针为正数\nconst originMaps: number[][] = [\n  [0, 0],\n  [0, -90],\n  [0, -180],\n  [0, 90],\n  [90, 0],\n  [-90, 0],\n];\n\nconst directionMaps = {\n  row: {\n    list: [0, 3, 2, 1],\n    deg: [0, 1],\n    plane2: '180',\n  },\n  'row-reverse': {\n    list: [0, 1, 2, 3],\n    deg: [0, -1],\n    plane2: '180',\n  },\n  column: {\n    list: [0, 4, 2, 5],\n    deg: [1, 0],\n    plane2: '0',\n  },\n  'column-reverse': {\n    list: [0, 5, 2, 4],\n    deg: [-1, 0],\n    plane2: '0',\n  },\n};\n\nconst transformValue = (x_y: number[]) => {\n  const [x = 0, y = 0] = x_y;\n  return `rotateX(${x}deg) rotateY(${y}deg)`;\n};\nconst Cube: React.FC<CubeProps> = (props) => {\n  const { speed = 1, planeNode, planeSize, unit = 'px', direction = 'row', fixed = false } = props;\n  const index = props.index % 6 >> 0;\n  const [sizeX, sizeY, sizeZ] = planeSize;\n  const dataStorage = useRef<dataStorageProps>({ lastIndex: null, lastDeg: [] });\n  // 缩放系数\n  // 由于使用了 perspective ，使得子元素 translateZ 值 将影响此元素的缩放比例\n  // 当 translateZ 的值为正值，代表此元素离你更近了，所以就变大了\n  // 当 translateZ 的值为负值，代表此元素离你更远了，所以就变小了\n  // getCoefficient 的作用就是把缩放的元素，还原至原始大小\n  const coefficient = useMemo((): number => {\n    const size = {\n      px() {\n        return sizeZ;\n      }, //0.902\n      rem() {\n        const HTML = document.getElementsByTagName('html')[0];\n        const fontSize = window.getComputedStyle(HTML, null).getPropertyValue('font-size');\n        return parseFloat(fontSize) * sizeZ;\n      },\n      vw() {\n        return (window.innerWidth / 100) * sizeZ;\n      },\n      vh() {\n        return (window.innerHeight / 100) * sizeZ;\n      },\n    }[unit]();\n    return 1200 / (1200 + size / 2);\n  }, [sizeZ, unit]);\n  const List = useMemo(() => {\n    const { plane2 } = directionMaps[direction];\n    return [\n      {\n        style: {\n          width: sizeX + unit,\n          height: sizeY + unit,\n          transform: `translateZ(${sizeZ / 2}${unit}) rotateX(0deg)`,\n        },\n      },\n      {\n        style: {\n          width: sizeZ + unit,\n          height: sizeY + unit,\n          transform: `translate3d(${sizeX - sizeZ / 2}${unit}, 0, 0) rotateY(90deg) `,\n        },\n      },\n      {\n        style: {\n          width: sizeX + unit,\n          height: sizeY + unit,\n          transform: `translateZ(${-sizeZ / 2}${unit}) rotateX(180deg) rotate(${plane2}deg)`,\n        },\n      },\n      {\n        style: {\n          width: sizeZ + unit,\n          height: sizeY + unit,\n          transform: `translate3d(${-(sizeX - sizeZ / 2)}${unit}, 0, 0) rotateY(-90deg) `,\n        },\n      },\n      {\n        style: {\n          width: sizeX + unit,\n          height: sizeZ + unit,\n          transform: `translate3d(0, ${sizeY - sizeZ / 2}${unit}, 0) rotateX(-90deg)`,\n        },\n      },\n      {\n        style: {\n          width: sizeX + unit,\n          height: sizeZ + unit,\n          transform: `translate3d(0, ${-(sizeY - sizeZ / 2)}${unit}, 0) rotateX(90deg)`,\n        },\n      },\n    ];\n  }, [planeSize, unit, direction]);\n  const transformMove = useMemo((): string => {\n    const { current } = dataStorage;\n    const { lastIndex, lastDeg } = current;\n    const { list, deg } = directionMaps[direction];\n    // 如果索引不在范围内，直接返回上一次的 度数，相当于不变化\n    if (!list.includes(index)) return transformValue(lastDeg);\n    // 如果是初始化， 直接返回上一个\n    if (lastIndex === null) {\n      // 记录上一个 索引,和 坐标值 为当前\n      dataStorage.current = {\n        lastIndex: index,\n        lastDeg: originMaps[index],\n      };\n      return transformValue(dataStorage.current.lastDeg);\n    }\n    const currentDeg = (() => {\n      return lastDeg.map((item, i) => {\n        let n = list.indexOf(index) - list.indexOf(lastIndex);\n        if (n === -3) {\n          n = 1;\n        }\n        if (n === 3) {\n          n = -1;\n        }\n        // 如果确定了轨迹，那么运动轨迹将始终往一个方向旋转，不会寻找最短路径\n        if (fixed && n < 0) {\n          n += 4;\n        }\n        return item + n * deg[i] * 90;\n      });\n    })();\n    /*******/\n    // 这尼玛真是个天坑啊！！！\n    // 不使用setTimeoust，修改 useref 的值，和赋值 useref 会引起渲染2次！\n    /*******/\n    setTimeout(() => {\n      // 记录上一个 索引,和 坐标值 为当前\n      dataStorage.current = {\n        lastIndex: index,\n        lastDeg: currentDeg,\n      };\n    });\n    return transformValue(currentDeg);\n  }, [index, direction]);\n  return (\n    <div className={`${Style['cube-container']}`} style={{ transform: `scale(${coefficient})` }}>\n      <div\n        className={`${Style['cube-info']}`}\n        style={{\n          transform: transformMove,\n          transitionDuration: speed + 's',\n          width: sizeX + unit,\n          height: sizeY + unit,\n        }}\n      >\n        {List.map((item, i) => {\n          return (\n            <div\n              className={`${Style['cube-item']} ${Style['cube-item-' + i]}`}\n              style={item.style}\n              key={i}\n            >\n              <div className={`${Style['item-info']}`}>{planeNode[i] ? planeNode[i] : ''}</div>\n            </div>\n          );\n        })}\n      </div>\n    </div>\n  );\n};\n\nexport default Cube;\n","/Users/a58/Desktop/my/beautiful/src/components/Fireworks/index.tsx",["57"],"/Users/a58/Desktop/my/beautiful/src/components/Fireworks/js/index.js",["58"],"// 从这个范围内，得出随机值\nexport const randomBetween = (from, to) => {\n  return Math.random() * (to - from) + from;\n};\nexport class Fireworks {\n  constructor(node, option = {}) {\n    const { color, interval = 80, count = 200, length = [5, 5] } = option;\n    this.canvas = node;\n    this.start = true;\n    this.timer = null;\n    this.ctx = this.canvas.getContext('2d');\n    // `hsla(${color}, 100%, ${this.brightness(65-75)}%, ${this.opacity})`\n    // color 值是hsla模式中第一个值\n\n    this.color = this.getColor(color);\n    // 粒子爆炸尾巴长度\n    this.length = () => randomBetween(...length) >> 0;\n    this.controller = {\n      particle: {\n        list: new Set(),\n        count: count,\n        length: 3,\n      },\n      firework: {\n        list: new Set(),\n        // 设置随机焰火产生的间隔，以及将产生多少焰火\n        timer: {\n          current: 40,\n          random: 35,\n          total: interval || 40, //数值越大，频率越低\n          batch: 1,\n          reset: () => {\n            this.controller.firework.timer.current = randomBetween(\n              0,\n              this.controller.firework.timer.random,\n            );\n            return this.controller.firework.timer;\n          },\n        },\n      },\n      // 背景星星数\n      star: {\n        list: new Set(),\n        count: 0,\n      },\n\n      // 重力加速度\n      // 值越大，物体向地面的拉力就越大\n      gravity: 0.1,\n\n      // 定义将当前队列保存为前一个队列的时间\n      // 值越大，跟踪时间越长\n      trail: {\n        length: 0,\n        width: 8,\n      },\n\n      // 定义焰火的起始位置\n      launchPosition: {\n        x: undefined,\n        y: undefined,\n        update: () => {\n          this.controller.launchPosition.x = this.canvas.width / 2;\n          this.controller.launchPosition.y = this.canvas.height;\n\n          return this.controller.launchPosition;\n        },\n      },\n\n      // 在画布上定义烟花将击中的区域\n      targetRectangle: {\n        x1: undefined,\n        x2: undefined,\n        y1: undefined,\n        y2: undefined,\n        update: () => {\n          this.controller.targetRectangle.x1 = this.canvas.width * 0.25;\n          this.controller.targetRectangle.x2 = this.canvas.width * 0.75;\n          this.controller.targetRectangle.y1 = this.canvas.height * 0.25;\n          this.controller.targetRectangle.y2 = this.canvas.height * 0.5;\n\n          return this.controller.targetRectangle;\n        },\n      },\n    };\n    this.mouse = {\n      x: 0,\n      y: 0,\n      isPressed: false,\n      limiter: {\n        current: 10,\n        target: 10,\n        reset: () => {\n          this.mouse.limiter.current = 0;\n        },\n      },\n    };\n\n    this.init();\n  }\n\n  init() {\n    this.updateCanvas();\n    this.createNewStars();\n    this.loop();\n  }\n  getColor(color) {\n    if (typeof color === 'string' && color) {\n      let arr = color.split(',');\n      if (arr.length === 2) {\n        return () => randomBetween(arr[0], arr[1]);\n      }\n      if (arr.length === 1) {\n        return () => color;\n      }\n    }\n    return () => randomBetween(0, 360);\n  }\n  clear() {\n    window.cancelAnimationFrame(this.timer);\n  }\n  move() {\n    // 偶尔发射随机烟火，以防止画布是空的\n    this.makeRandomFireworks();\n    //console.log(9999);\n    // 清除之前循环中绘制的所有内容\n    this.clearCanvas();\n\n    // 绘制并更新所有内容\n    this.controller.firework.list.forEach((firework) => {\n      if (firework.reachedTarget) {\n        firework.explode();\n      } else {\n        firework.update().draw();\n      }\n    });\n\n    this.controller.particle.list.forEach((particle) => {\n      if (particle.disappeared) {\n        this.controller.particle.list.delete(particle);\n      } else {\n        particle.update().draw();\n      }\n    });\n\n    this.controller.star.list.forEach((star) => {\n      if (star.disappeared) {\n        this.controller.star.list.delete(star);\n      } else {\n        star.update().draw();\n      }\n    });\n    this.createNewStars();\n\n    // 单击生成烟火，将达到鼠标的位置\n    if (this.mouse.isPressed) this.makeMouseGeneratedFirework();\n  }\n  loop() {\n    this.move();\n    this.timer = window.requestAnimationFrame(this.loop.bind(this, Date.now()));\n  }\n  updateCanvas() {\n    // 使画布填充整个文档\n    // 基于新的画布尺寸更新启动位置和目标位置\n    this.controller.launchPosition.update();\n    this.controller.targetRectangle.update();\n  }\n  clearCanvas() {\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    // 使粒子相互重叠\n    this.ctx.globalCompositeOperation = 'lighter';\n  }\n  makeRandomFireworks() {\n    // controller.firework.timer.total 设置随机烟火产生的间隔\n    this.controller.firework.timer.current++;\n    if (this.controller.firework.timer.current >= this.controller.firework.timer.total) {\n      for (let i = 0; i < this.controller.firework.timer.batch; i++) {\n        // 在目标区域内随机选择一个点\n        const randomCoords = {\n          x: randomBetween(this.controller.targetRectangle.x1, this.controller.targetRectangle.x2),\n          y: randomBetween(this.controller.targetRectangle.y1, this.controller.targetRectangle.y2),\n        };\n        this.controller.firework.list.add(\n          new Firework(\n            this.controller.launchPosition.x,\n            this.controller.launchPosition.y,\n            randomCoords.x,\n            randomCoords.y,\n            this,\n          ),\n        );\n      }\n      this.controller.firework.timer.reset();\n    }\n  }\n  makeMouseGeneratedFirework() {\n    if (this.mouse.limiter.current >= this.mouse.limiter.target) {\n      this.controller.firework.list.add(\n        new Firework(\n          this.controller.launchPosition.x,\n          this.controller.launchPosition.y,\n          this.mouse.x,\n          this.mouse.y,\n          this,\n        ),\n      );\n      this.mouse.limiter.reset();\n    } else {\n      this.mouse.limiter.current++;\n    }\n  }\n  createNewStars() {\n    while (this.controller.star.list.size < this.controller.star.count) {\n      this.controller.star.list.add(new Star(this));\n    }\n  }\n}\nclass Firework {\n  // 烟花是用给定的起点和目标点在画布上构造的\n  constructor(startX, startY, targetX, targetY, context) {\n    this.context = context;\n    this.coords = {\n      current: {\n        x: startX,\n        y: startY,\n      },\n      previous: new Array(this.context.controller.trail.length).fill({\n        x: startX,\n        y: startY,\n      }),\n      target: {\n        x: targetX,\n        y: targetY,\n      },\n    };\n\n    // 通过知道重力加速度、起始点和目标点，可以计算出弹丸在重力场中的初速度和运动时间\n\n    // a -> 重力加速度(恒定重力)\n    // v0 -> 初始y轴速度\n    // u0 -> 初始x轴速度\n    // t -> time in air 在空中的时间\n    // h -> 沿着y轴移动的高度(startY - targetY) ->在canvas中，我们认为“更高”的点具有较低的y值，因为值从上到下递增)\n    // s -> 沿x轴移动的距离(targetX - startX)\n\n    this.velocity = {\n      // 我们希望当弹丸到达目标时，y轴速度逐渐降低并达到0\n\n      // y轴抛物运动方程:\n      // v0 = at\n      // h = v0t - at^2/2\n\n      // 因此 v0 = sqrt(2ah)\n      y: Math.sqrt(2 * this.context.controller.gravity * (startY - targetY)),\n\n      // 同时，它也应该到达它的x轴目的地:\n      // u0 = s / t\n\n      // 我们已经知道了y轴速度，所以我们可以计算在空中的时间:\n      // t = v0 / a,\n\n      // so:\n      // u0 = s / (v0 / a)\n      // u0 = s * a / v0\n\n      x:\n        ((targetX - startX) * this.context.controller.gravity) /\n        Math.sqrt(2 * this.context.controller.gravity * (startY - targetY)),\n    };\n\n    // 这个属性存储烟花已经旅行和应该旅行的时间\n    this.time = {\n      inAir: 0,\n\n      // t = v0 / a\n      toTravel: this.velocity.y / this.context.controller.gravity,\n    };\n\n    // 此属性存储指示烟花目标的环的值\n    this.ring = {\n      hue: 0,\n      angle: 0,\n      sector: (Math.PI * 4) / 3, // 整个圆的 0.66\n    };\n\n    this.gravity = this.context.controller.gravity;\n  }\n\n  update() {\n    // 更新空中时间\n    this.time.inAir++;\n\n    // 将当前坐标保存为上一个坐标\n    this.coords.previous.push({\n      x: this.coords.current.x,\n      y: this.coords.current.y,\n    });\n    this.coords.previous.splice(0, 1);\n\n    // 更新坐标\n    this.coords.current.x += this.velocity.x;\n    this.coords.current.y -= this.velocity.y;\n\n    // 更新速度\n    this.velocity.y -= this.gravity;\n    // this.velocity.x 不会改变(我们在计算中不包括拖拽)\n\n    // 更新目标圆\n    this.ring.hue += 2;\n    this.ring.angle += 0.04;\n\n    return this;\n  }\n\n  draw() {\n    this.drawTrail();\n    // 对不起，我不喜欢这个环，不要给妇女套环\n    //this.drawRing();\n\n    return this;\n  }\n\n  drawTrail() {\n    this.context.ctx.beginPath();\n    this.context.ctx.moveTo(this.coords.current.x, this.coords.current.y);\n\n    for (let i = this.coords.previous.length - 1; i > 0; i--) {\n      const position = this.coords.previous[i];\n\n      this.context.ctx.lineTo(position.x, position.y);\n      this.context.ctx.lineWidth = this.context.controller.trail.width;\n\n      const opacity = i / this.context.controller.trail.length;\n\n      this.context.ctx.strokeStyle = `hsla(40, 100%, 80%, ${opacity * 100}%)`;\n      this.context.ctx.stroke();\n\n      // 如果这不是数组中的最后一个位置，开始画新行\n      if (i != 1) {\n        this.context.ctx.beginPath();\n        this.context.ctx.moveTo(position.x, position.y);\n      }\n    }\n  }\n\n  drawRing() {\n    this.context.ctx.beginPath();\n    this.context.ctx.arc(\n      this.coords.target.x,\n      this.coords.target.y,\n      8,\n      this.ring.angle,\n      this.ring.angle + (Math.PI * 4) / 3,\n    );\n\n    let opacity = 1;\n    //当烟花靠近目标时，环会慢慢消失\n    if (this.time.toTravel - this.time.inAir < 40) {\n      opacity = (this.time.toTravel - this.time.inAir) / 40; // 返回0到1之间的分数\n    }\n    this.context.ctx.strokeStyle = `hsla(${this.ring.hue}, 100%, 10%, ${opacity})`;\n    this.context.ctx.lineWidth = 2;\n    this.context.ctx.stroke();\n  }\n\n  explode() {\n    // 为同一烟花中的粒子选择一个随机的颜色 // 随机randomBetween(0, 360)\n    const givenHue = this.context.color();\n    // 粒子爆炸尾巴长度\n    const length = this.context.length();\n    // 在爆炸位置创建新的粒子\n    for (let i = 0; i < this.context.controller.particle.count; i++) {\n      this.context.controller.particle.list.add(\n        new Particle(this.coords.target.x, this.coords.target.y, givenHue, this.context, length),\n      );\n    }\n\n    // 创建粒子后，从集合中删除烟花\n    this.context.controller.firework.list.delete(this);\n  }\n\n  get reachedTarget() {\n    return this.time.inAir >= this.time.toTravel;\n  }\n}\nclass Particle {\n  constructor(startX, startY, givenHue, context, length) {\n    this.context = context;\n    this.coords = {\n      current: {\n        x: startX,\n        y: startY,\n      },\n      //this.context.controller.particle.length\n      previous: new Array(length).fill({\n        x: startX,\n        y: startY,\n      }),\n    };\n\n    // 设置随机发射角度和速度\n    this.angle = randomBetween(0, Math.PI * 2);\n    this.velocity = randomBetween(0, 10);\n\n    // 为同一焰火中的所有粒子设置稍微不同的色调\n    this.hue = givenHue + randomBetween(-10, 10);\n\n    this.brightness = randomBetween(65, 75);\n    this.opacity = 1;\n\n    // 设定粒子消失的速度\n    this.fade = randomBetween(0.01, 0.03);\n  }\n\n  update() {\n    // 删除最后一个坐标并push新的坐标\n    this.coords.previous.shift();\n    this.coords.previous.push([this.coords.current.x, this.coords.current.y]);\n    // 使粒子减速\n    this.velocity *= 0.95;\n    // 改变坐标\n    this.coords.current.x += Math.cos(this.angle) * this.velocity;\n    this.coords.current.y +=\n      Math.sin(this.angle) * this.velocity + this.context.controller.gravity * 10;\n    // 改变透明度\n    this.opacity -= this.fade;\n    // 移除不可见的粒子以防止性能问题\n\n    return this;\n  }\n\n  draw() {\n    // 移动到前一个位置，并画线到当前的位置\n    this.context.ctx.beginPath();\n    this.context.ctx.lineWidth = randomBetween(2, 4);\n    this.context.ctx.moveTo(this.coords.previous[0][0], this.coords.previous[0][1]);\n    this.context.ctx.lineTo(this.coords.current.x, this.coords.current.y);\n    this.context.ctx.strokeStyle = `hsla(${this.hue}, 100%, ${this.brightness}%, ${this.opacity})`;\n    this.context.ctx.stroke();\n\n    return this;\n  }\n\n  get disappeared() {\n    return this.opacity < this.fade;\n  }\n}\nclass Star {\n  constructor(context) {\n    this.context = context;\n    this.coords = {\n      x: Math.floor(randomBetween(0, this.context.canvas.width)),\n      y: Math.floor(randomBetween(0, this.context.canvas.height)),\n    };\n    this.size = Math.ceil(randomBetween(0, 2));\n    this.life = {\n      current: 0,\n      target: Math.floor(randomBetween(150, 300)),\n    };\n    this.opacity = 0;\n  }\n  update() {\n    this.life.current++;\n\n    // 在开始时增加星星的透明度，最后逐渐淡入\n    if (this.life.current < 50) {\n      this.opacity = this.life.current / 50; // 从0增加到1\n    } else if (this.life.current > this.life.target - 50) {\n      this.opacity = (this.life.target - this.life.current) / 50; // 从1减少到0\n    } else this.opacity = 1;\n\n    return this;\n  }\n\n  draw() {\n    // 用圆圈画星星\n    this.context.ctx.beginPath();\n    this.context.ctx.arc(this.coords.x, this.coords.y, this.size, 0, 2 * Math.PI);\n    this.context.ctx.fillStyle = `hsla(60, 100%, 20%, ${this.opacity}`;\n    this.context.ctx.fill();\n\n    return this;\n  }\n\n  get disappeared() {\n    return this.opacity < 0;\n  }\n}\n",["59","60"],{"ruleId":"61","replacedBy":"62"},{"ruleId":"63","replacedBy":"64"},{"ruleId":"61","replacedBy":"65"},{"ruleId":"63","replacedBy":"66"},{"ruleId":"67","severity":1,"message":"68","line":159,"column":6,"nodeType":"69","endLine":159,"endColumn":34,"suggestions":"70"},{"ruleId":"67","severity":1,"message":"71","line":203,"column":6,"nodeType":"69","endLine":203,"endColumn":24,"suggestions":"72"},{"ruleId":"73","severity":1,"message":"74","line":7,"column":11,"nodeType":"75","messageId":"76","endLine":7,"endColumn":19},{"ruleId":"67","severity":1,"message":"68","line":159,"column":6,"nodeType":"69","endLine":159,"endColumn":34,"suggestions":"77"},{"ruleId":"67","severity":1,"message":"71","line":203,"column":6,"nodeType":"69","endLine":203,"endColumn":24,"suggestions":"78"},{"ruleId":"67","severity":1,"message":"79","line":44,"column":6,"nodeType":"69","endLine":44,"endColumn":8,"suggestions":"80"},{"ruleId":"81","severity":1,"message":"82","line":339,"column":13,"nodeType":"83","messageId":"84","endLine":339,"endColumn":15},{"ruleId":"61","replacedBy":"62"},{"ruleId":"63","replacedBy":"64"},"no-native-reassign",["85"],"no-negated-in-lhs",["86"],["85"],["86"],"react-hooks/exhaustive-deps","React Hook useMemo has missing dependencies: 'sizeX', 'sizeY', and 'sizeZ'. Either include them or remove the dependency array.","ArrayExpression",["87"],"React Hook useMemo has a missing dependency: 'fixed'. Either include it or remove the dependency array.",["88"],"@typescript-eslint/no-unused-vars","'anyProps' is defined but never used.","Identifier","unusedVar",["89"],["90"],"React Hook useEffect has a missing dependency: 'other'. Either include it or remove the dependency array.",["91"],"eqeqeq","Expected '!==' and instead saw '!='.","BinaryExpression","unexpected","no-global-assign","no-unsafe-negation",{"desc":"92","fix":"93"},{"desc":"94","fix":"95"},{"desc":"92","fix":"96"},{"desc":"94","fix":"97"},{"desc":"98","fix":"99"},"Update the dependencies array to be: [direction, sizeX, unit, sizeY, sizeZ]",{"range":"100","text":"101"},"Update the dependencies array to be: [direction, index, fixed]",{"range":"102","text":"103"},{"range":"104","text":"101"},{"range":"105","text":"103"},"Update the dependencies array to be: [other]",{"range":"106","text":"107"},[4224,4252],"[direction, sizeX, unit, sizeY, sizeZ]",[5480,5498],"[direction, index, fixed]",[4224,4252],[5480,5498],[1106,1108],"[other]"]